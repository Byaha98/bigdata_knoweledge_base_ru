

# Ответ на тестовое задание на аналитика данных в Контур



Развертка базы данных в Docker

```
docker pull [mcr.microsoft.com/mssql/server:latest](http://mcr.microsoft.com/mssql/server:latest)
```


Решил взять последнюю версию

  ![[DA_testovoe_kontur_7.png]]



Запуск контейнера

```


docker run -e "ACCEPT_EULA=Y" \

  -e "MSSQL_SA_PASSWORD=YourNew@Pass123" \

  -p 1433:1433 \

  --name sql_server_container \

  -d mcr.microsoft.com/mssql/server:latest
```
#### Создал все необходимые таблицы в БД. Проверил работоспособность скрипта

![[DA_testovoe_kontur_8.png]]

  
  
#### Код скрипта: 

  

#### WITH RankedBills AS (

####   SELECT

####       c.cID,

####       c.Name,

####       c.Inn,

####       b.bID,

####       b.Num,

####       b.BDate,

####       b.PayDate,

####       ROW_NUMBER() OVER (

####           PARTITION BY c.cID

####           ORDER BY

####               CASE

####                   WHEN rp.UpTo IS NOT NULL

####                    AND rp.Since <= '2021-01-01'

####                    AND rp.UpTo >= '2021-01-01'

####                   THEN 1  -- активные поставки (первый приоритет)

####                   ELSE 2   -- неактивные (второй приоритет)

####               END,

####               CASE

####                   WHEN rp.UpTo IS NOT NULL

####                    AND rp.Since <= '2021-01-01'

####                    AND rp.UpTo >= '2021-01-01'

####                   THEN rp.UpTo

####               END DESC,

####               CASE

####                   WHEN (rp.UpTo IS NULL OR rp.Since > '2021-01-01' OR rp.UpTo < '2021-01-01')

####                    AND bc.TypeID IN (1, 2)  -- 1=подключение, 2=продление

####                    AND b.PayDate IS NOT NULL

####                   THEN b.PayDate

####               END DESC

####       ) AS BillRank

####   FROM

####       Clients c

####       INNER JOIN Bills b ON c.cID = b.cID

####       INNER JOIN BillContent bc ON b.bID = bc.bID

####       LEFT JOIN RetailPacks rp ON bc.bcID = rp.bcID

####   WHERE

####       bc.Product = N'Контур-Экстерн'

#### )

#### SELECT

####   rb.Name,

####   rb.Inn,

####   rb.Num,

####   rb.BDate,

####   rb.PayDate,

####   ROUND(SUM(bc.Cost), 2) AS BillSum,

####   ROUND(SUM(bc.Paid), 2) AS BillPay

#### FROM

####   RankedBills rb

####   INNER JOIN BillContent bc ON rb.bID = bc.bID

#### WHERE

####   rb.BillRank = 1

#### GROUP BY

####   rb.bID, rb.Name, rb.Inn, rb.Num, rb.BDate, rb.PayDate

#### ORDER BY rb.Name;




Написал скрипт согласно заданию.

Соблюдение условий для скрипта:

1.Открытая поставка на 2021-01-01

2.Продукт - “Контурн-Экстерн”

3.Максимальная дата окончания, если счетов несколько (ранг 1 в оконке)

4.Запасное условие.

5.Необходимые по условию суммы

6.Все JOIN-ы, кроме RetailPacks, — INNER JOIN, потому что их наличие гарантировано структурой данных. Только RetailPacks — LEFT JOIN, потому что поставки могут отсутствовать, а бизнес-логика требует учитывать и такие случаи.

  

Подробнее по условиям в оконке:

### 1. Первое условие (CASE ... THEN 1 ELSE 2)

CASE 

    WHEN rp.UpTo IS NOT NULL 

     AND rp.Since <= '2021-01-01' 

     AND rp.UpTo >= '2021-01-01' 

    THEN 1  -- активные поставки (первый приоритет)

    ELSE 2   -- неактивные (второй приоритет)

END

Что делает?

- Группирует записи на две категории:
    

- 1 — активные поставки (действующие на 01.01.2021).
    
- 2 — все остальные (неактивные, просроченные или без поставки).
    

- Гарантирует, что все активные поставки (1) будут в начале списка, а неактивные (2) — после них.
    

Но этого недостаточно!  
Потому что внутри каждой группы (1 или 2) записи могут идти в произвольном порядке. Нам же нужно:

- Среди активных поставок (1) выбрать с максимальной датой окончания (rp.UpTo).
    
- Среди неактивных (2) выбрать с максимальной датой оплаты (PayDate).
    

### 2. Второе условие (CASE ... THEN rp.UpTo END DESC)

CASE 

    WHEN rp.UpTo IS NOT NULL 

     AND rp.Since <= '2021-01-01' 

     AND rp.UpTo >= '2021-01-01' 

    THEN rp.UpTo  -- сортировка активных поставок по дате окончания

END DESC

Что делает?

- Только для активных поставок (условие совпадает с первым CASE) добавляет сортировку по rp.UpTo DESC.
    
- Для неактивных (ELSE 2) возвращает NULL, и они не сортируются по этому полю (остаются в произвольном порядке).
    

Зачем?  
Чтобы среди всех активных поставок выбрать ту, у которой:

- Самая поздняя дата окончания (rp.UpTo DESC).  
    Это соответствует условию задачи:
    

"вывести тот счет, по которому создана открытая поставка с максимальной датой окончания".

### 3. Третье условие (CASE ... THEN PayDate END DESC)

CASE 

    WHEN (rp.UpTo IS NULL OR rp.Since > '2021-01-01' OR rp.UpTo < '2021-01-01')

     AND bc.TypeID IN (1, 2)  -- подключение или продление

    THEN b.PayDate 

END DESC

Что делает?

- Работает только для неактивных поставок (условие обратное первому CASE, запасное условие).
    
- Сортирует их по PayDate DESC.
    

“Если нет счетов, удовлетворяющих данному условию, необходимо вывести счет с максимальной датой оплаты, в котором есть строки на «Контур-Экстерн» на подключение или продление. Не более одного счета на клиента”
